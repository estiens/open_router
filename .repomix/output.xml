This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-15T18:42:42.365Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    main.yml
bin/
  console
  setup
examples/
  model_selection_example.rb
  smart_completion_example.rb
  structured_outputs_example.rb
  tool_calling_example.rb
lib/
  open_router/
    client.rb
    http.rb
    model_registry.rb
    model_selector.rb
    response.rb
    schema.rb
    tool_call.rb
    tool.rb
    version.rb
  open_router.rb
sig/
  open_router.rbs
.gitignore
.repomixignore
.rspec
.ruby-version
Gemfile
Gemfile.lock
LICENSE.txt
open_router.gemspec
Rakefile
test_structured_output_fix.rb
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/main.yml">
 1: name: Ruby
 2: on:
 3:   push:
 4:     branches:
 5:       - main
 6:   pull_request:
 7: jobs:
 8:   build:
 9:     runs-on: ubuntu-latest
10:     name: Ruby ${{ matrix.ruby }}
11:     strategy:
12:       matrix:
13:         ruby:
14:           - '3.2.2'
15:     steps:
16:     - uses: actions/checkout@v3
17:     - name: Set up Ruby
18:       uses: ruby/setup-ruby@v1
19:       with:
20:         ruby-version: ${{ matrix.ruby }}
21:         bundler-cache: true
22:     - name: Run the default task
23:       run: bundle exec rake
24:       env:
25:         ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
</file>

<file path="bin/console">
 1: #!/usr/bin/env ruby
 2: # frozen_string_literal: true
 3: 
 4: require "bundler/setup"
 5: require "open_router"
 6: 
 7: # You can add fixtures and/or initialization code here to make experimenting
 8: # with your gem easier. You can also use a different console, if you like.
 9: 
10: require "irb"
11: IRB.start(__FILE__)
</file>

<file path="bin/setup">
1: #!/usr/bin/env bash
2: set -euo pipefail
3: IFS=$'\n\t'
4: set -vx
5: 
6: bundle install
7: 
8: # Do any other automated setup that you need to do here
</file>

<file path="examples/model_selection_example.rb">
  1: require "open_router"
  2: OpenRouter.configure do |config|
  3:   config.access_token = ENV["OPENROUTER_API_KEY"] || "your-api-key-here"
  4:   config.site_name = "ModelSelector Example"
  5:   config.site_url = "https://example.com"
  6: end
  7: puts "🤖 OpenRouter ModelSelector Examples"
  8: puts "=" * 50
  9: puts "\n1. Basic cost optimization:"
 10: selector = OpenRouter::ModelSelector.new
 11: cheapest_model = selector.optimize_for(:cost).choose
 12: if cheapest_model
 13:   puts "   Cheapest model: #{cheapest_model}"
 14:   cost_info = OpenRouter::ModelRegistry.get_model_info(cheapest_model)
 15:   puts "   Cost: $#{cost_info[:cost_per_1k_tokens][:input]} per 1k input tokens"
 16: else
 17:   puts "   No models available"
 18: end
 19: puts "\n2. Models with function calling capability:"
 20: function_models = OpenRouter::ModelSelector.new
 21:                                            .require(:function_calling)
 22:                                            .optimize_for(:cost)
 23:                                            .choose_with_fallbacks(limit: 3)
 24: if function_models.any?
 25:   function_models.each_with_index do |model, i|
 26:     puts "   #{i + 1}. #{model}"
 27:   end
 28: else
 29:   puts "   No models with function calling found"
 30: end
 31: puts "\n3. Budget-constrained selection ($0.01 max, with vision):"
 32: budget_model = OpenRouter::ModelSelector.new
 33:                                         .within_budget(max_cost: 0.01)
 34:                                         .require(:vision)
 35:                                         .optimize_for(:cost)
 36:                                         .choose
 37: if budget_model
 38:   puts "   Selected: #{budget_model}"
 39:   model_info = OpenRouter::ModelRegistry.get_model_info(budget_model)
 40:   puts "   Capabilities: #{model_info[:capabilities].join(", ")}"
 41:   puts "   Cost: $#{model_info[:cost_per_1k_tokens][:input]} per 1k input tokens"
 42: else
 43:   puts "   No models found within budget with vision capability"
 44: end
 45: puts "\n4. Prefer specific providers:"
 46: provider_model = OpenRouter::ModelSelector.new
 47:                                           .prefer_providers("anthropic", "openai")
 48:                                           .require(:function_calling)
 49:                                           .optimize_for(:cost)
 50:                                           .choose
 51: if provider_model
 52:   puts "   Selected: #{provider_model}"
 53:   provider = provider_model.split("/").first
 54:   puts "   Provider: #{provider}"
 55: else
 56:   puts "   No models found from preferred providers"
 57: end
 58: puts "\n5. Latest models (with graceful fallback):"
 59: latest_model = OpenRouter::ModelSelector.new
 60:                                         .optimize_for(:latest)
 61:                                         .require(:function_calling)
 62:                                         .min_context(100_000)
 63:                                         .choose_with_fallback
 64: if latest_model
 65:   puts "   Selected: #{latest_model}"
 66:   model_info = OpenRouter::ModelRegistry.get_model_info(latest_model)
 67:   puts "   Context length: #{model_info[:context_length]} tokens"
 68:   puts "   Released: #{Time.at(model_info[:created_at])}"
 69: else
 70:   puts "   No suitable models found"
 71: end
 72: puts "\n6. Complex requirements with method chaining:"
 73: complex_selector = OpenRouter::ModelSelector.new
 74:                                             .optimize_for(:performance)
 75:                                             .require(:function_calling, :structured_outputs)
 76:                                             .within_budget(max_cost: 0.05)
 77:                                             .avoid_patterns("*-free", "*-preview")
 78:                                             .prefer_providers("anthropic", "openai")
 79: models = complex_selector.choose_with_fallbacks(limit: 2)
 80: if models.any?
 81:   puts "   Found #{models.length} suitable models:"
 82:   models.each_with_index do |model, i|
 83:     model_info = OpenRouter::ModelRegistry.get_model_info(model)
 84:     puts "   #{i + 1}. #{model} (#{model_info[:performance_tier]} tier)"
 85:   end
 86: else
 87:   puts "   No models meet all requirements"
 88: end
 89: puts "\n7. Cost estimation:"
 90: if cheapest_model
 91:   estimated_cost = OpenRouter::ModelSelector.new.estimate_cost(
 92:     cheapest_model,
 93:     input_tokens: 2000,
 94:     output_tokens: 500
 95:   )
 96:   puts "   Cost for 2000 input + 500 output tokens with #{cheapest_model}:"
 97:   puts "   $#{estimated_cost.round(6)}"
 98: end
 99: puts "\n8. Selection criteria:"
100: criteria = OpenRouter::ModelSelector.new
101:                                     .optimize_for(:cost)
102:                                     .require(:function_calling)
103:                                     .within_budget(max_cost: 0.02)
104:                                     .selection_criteria
105: puts "   Strategy: #{criteria[:strategy]}"
106: puts "   Required capabilities: #{criteria[:requirements][:capabilities]}"
107: puts "   Max cost: $#{criteria[:requirements][:max_input_cost]}"
108: puts "\n✅ ModelSelector examples completed!"
</file>

<file path="examples/smart_completion_example.rb">
 1: require "open_router"
 2: puts "🧠 Smart Completion Examples"
 3: puts "=" * 40
 4: client = OpenRouter::Client.new
 5: puts "\n1. Using select_model helper:"
 6: selector = client.select_model
 7:                  .optimize_for(:cost)
 8:                  .require(:function_calling)
 9:                  .within_budget(max_cost: 0.01)
10: selected_model = selector.choose
11: puts "   Selected model: #{selected_model}"
12: puts "\n2. Smart completion interface:"
13: requirements = {
14:   capabilities: [:function_calling],
15:   max_input_cost: 0.01,
16:   providers: {
17:     prefer: %w[anthropic openai],
18:     avoid: ["google"]
19:   }
20: }
21: messages = [
22:   { role: "user", content: "What is the weather like today?" }
23: ]
24: puts "   Requirements: #{requirements}"
25: puts "   Messages: #{messages}"
26: selector_for_smart = OpenRouter::ModelSelector.new
27:                                               .optimize_for(:cost)
28:                                               .require(*requirements[:capabilities])
29:                                               .within_budget(max_cost: requirements[:max_input_cost])
30:                                               .prefer_providers(*requirements[:providers][:prefer])
31:                                               .avoid_providers(*requirements[:providers][:avoid])
32: smart_model = selector_for_smart.choose
33: puts "   Would use model: #{smart_model}"
34: puts "\n3. Smart completion with fallback:"
35: fallback_requirements = {
36:   capabilities: %i[function_calling vision],
37:   max_input_cost: 0.005,
38:   min_context_length: 100_000
39: }
40: fallback_selector = OpenRouter::ModelSelector.new
41:                                              .optimize_for(:cost)
42:                                              .require(*fallback_requirements[:capabilities])
43:                                              .within_budget(max_cost: fallback_requirements[:max_input_cost])
44:                                              .min_context(fallback_requirements[:min_context_length])
45: fallback_models = fallback_selector.choose_with_fallbacks(limit: 3)
46: puts "   Fallback candidates: #{fallback_models}"
47: puts "\n4. Graceful degradation example:"
48: degradation_model = fallback_selector.choose_with_fallback
49: puts "   Graceful fallback selected: #{degradation_model}"
50: puts "\n5. Available Client methods:"
51: puts "   - client.select_model() -> ModelSelector"
52: puts "   - client.smart_complete(messages, requirements:, optimization:)"
53: puts "   - client.smart_complete_with_fallback(messages, requirements:, max_retries:)"
54: puts "\n✅ Smart completion examples completed!"
55: puts "\n💡 To test with real API calls:"
56: puts "   export OPENROUTER_API_KEY=your_key_here"
57: puts "   ruby -I lib examples/smart_completion_example.rb"
</file>

<file path="examples/structured_outputs_example.rb">
  1: require "bundler/setup"
  2: require "open_router"
  3: OpenRouter.configure do |config|
  4:   config.access_token = ENV["OPENROUTER_API_KEY"]
  5:   config.site_name = "OpenRouter Ruby Gem Example"
  6:   config.site_url = "https://github.com/OlympiaAI/open_router"
  7: end
  8: OpenRouter::Client.new
  9: puts "=== Example 1: Simple Weather Schema ==="
 10: weather_schema = OpenRouter::Schema.define("weather") do
 11:   strict true
 12:   string :location, required: true, description: "City or location name"
 13:   number :temperature, required: true, description: "Temperature in Celsius"
 14:   string :conditions, required: true, description: "Weather conditions"
 15:   string :humidity, description: "Humidity percentage"
 16:   no_additional_properties
 17: end
 18: puts "Schema definition:"
 19: puts weather_schema.to_json
 20: puts "\n=== Example 2: Complex User Profile Schema ==="
 21: user_schema = OpenRouter::Schema.define("user_profile") do
 22:   string :name, required: true, description: "Full name"
 23:   integer :age, required: true, minimum: 0, maximum: 150
 24:   string :email, required: true, description: "Email address"
 25:   object :address, required: true do
 26:     string :street, required: true
 27:     string :city, required: true
 28:     string :state, required: true
 29:     string :zip_code, required: true
 30:   end
 31:   array :hobbies do
 32:     string description: "A hobby or interest"
 33:   end
 34:   object :preferences do
 35:     boolean :newsletter, description: "Wants to receive newsletter"
 36:     string :theme, description: "UI theme preference"
 37:   end
 38: end
 39: puts "User schema:"
 40: puts JSON.pretty_generate(user_schema.to_h)
 41: puts "\n=== Example 3: Structured Output API Call ==="
 42: mock_weather_response = {
 43:   "id" => "chatcmpl-123",
 44:   "choices" => [
 45:     {
 46:       "message" => {
 47:         "role" => "assistant",
 48:         "content" => '{"location": "San Francisco", "temperature": 22, "conditions": "Partly cloudy", "humidity": "65%"}'
 49:       }
 50:     }
 51:   ]
 52: }
 53: response = OpenRouter::Response.new(mock_weather_response, response_format: weather_schema)
 54: puts "Parsed structured output:"
 55: puts response.structured_output.inspect
 56: if response.valid_structured_output?
 57:   puts "✅ Output is valid according to schema"
 58: else
 59:   puts "❌ Output validation failed:"
 60:   puts response.validation_errors
 61: end
 62: puts "\n=== Example 4: Different Response Format Styles ==="
 63: format1 = weather_schema
 64: format2 = {
 65:   type: "json_schema",
 66:   json_schema: weather_schema
 67: }
 68: format3 = {
 69:   type: "json_schema",
 70:   json_schema: {
 71:     name: "simple_weather",
 72:     strict: true,
 73:     schema: {
 74:       type: "object",
 75:       properties: {
 76:         temp: { type: "number" },
 77:         desc: { type: "string" }
 78:       },
 79:       required: %w[temp desc],
 80:       additionalProperties: false
 81:     }
 82:   }
 83: }
 84: puts "All three formats are supported:"
 85: puts "1. Direct schema object: #{format1.class}"
 86: puts "2. Hash with schema object: #{format2[:json_schema].class}"
 87: puts "3. Raw hash format: #{format3[:json_schema].class}"
 88: puts "\n=== Example 5: Real API Usage ==="
 89: puts "\n(Structured outputs example complete - uncomment the API call section to test with real API)"
 90: puts "\n=== Example 6: Schema Validation Demo ==="
 91: if weather_schema.validation_available?
 92:   puts "JSON Schema validation is available"
 93:   valid_data = {
 94:     "location" => "London",
 95:     "temperature" => 18,
 96:     "conditions" => "Rainy"
 97:   }
 98:   invalid_data = {
 99:     "location" => "London",
100:     "temperature" => "eighteen",
101:     "conditions" => "Rainy"
102:   }
103:   puts "Valid data validation: #{weather_schema.validate(valid_data)}"
104:   puts "Invalid data validation: #{weather_schema.validate(invalid_data)}"
105:   unless weather_schema.validate(invalid_data)
106:     puts "Validation errors for invalid data:"
107:     weather_schema.validation_errors(invalid_data).each do |error|
108:       puts "  - #{error}"
109:     end
110:   end
111: else
112:   puts "JSON Schema validation not available (install json-schema gem for validation)"
113: end
</file>

<file path="examples/tool_calling_example.rb">
 1: require "bundler/setup"
 2: require "open_router"
 3: OpenRouter.configure do |config|
 4:   config.access_token = ENV["OPENROUTER_API_KEY"]
 5:   config.site_name = "OpenRouter Ruby Gem Example"
 6:   config.site_url = "https://github.com/OlympiaAI/open_router"
 7: end
 8: OpenRouter::Client.new
 9: puts "=== Example 1: Tool Definition with DSL ==="
10: search_tool = OpenRouter::Tool.define do
11:   name "search_gutenberg_books"
12:   description "Search for books in the Project Gutenberg library"
13:   parameters do
14:     array :search_terms, required: true do
15:       string description: "Search term for finding books"
16:     end
17:     integer :max_results, description: "Maximum number of results to return"
18:   end
19: end
20: puts "Tool definition:"
21: puts search_tool.to_json
22: puts "\n=== Example 2: Tool Definition with Hash ==="
23: weather_tool = OpenRouter::Tool.new({
24:                                       name: "get_weather",
25:                                       description: "Get current weather for a location",
26:                                       parameters: {
27:                                         type: "object",
28:                                         properties: {
29:                                           location: {
30:                                             type: "string",
31:                                             description: "City and state, e.g. San Francisco, CA"
32:                                           },
33:                                           unit: {
34:                                             type: "string",
35:                                             enum: %w[celsius fahrenheit],
36:                                             description: "Temperature unit"
37:                                           }
38:                                         },
39:                                         required: ["location"]
40:                                       }
41:                                     })
42: puts "Tool definition:"
43: puts weather_tool.to_json
44: puts "\n=== Example 3: Tool Calling Conversation ==="
45: def simulate_search(_search_terms, max_results = 10)
46:   results = [
47:     { title: "Programming Ruby", author: "Dave Thomas", year: 2004 },
48:     { title: "The Ruby Programming Language", author: "David Flanagan", year: 2008 }
49:   ]
50:   results.first(max_results).to_json
51: end
52: def simulate_weather(location, unit = "fahrenheit")
53:   {
54:     location:,
55:     temperature: unit == "celsius" ? 22 : 72,
56:     conditions: "Sunny",
57:     unit:
58:   }.to_json
59: end
60: messages = [
61:   { role: "user", content: "Can you search for Ruby programming books and also tell me the weather in San Francisco?" }
62: ]
63: puts "User: #{messages.first[:content]}"
64: puts "\n(Tool calling example complete - uncomment the API call section to test with real API)"
</file>

<file path="lib/open_router/client.rb">
  1: require "active_support/core_ext/object/blank"
  2: require "active_support/core_ext/hash/indifferent_access"
  3: require "set"
  4: require_relative "http"
  5: module OpenRouter
  6:   class ServerError < StandardError; end
  7:   class Client
  8:     include OpenRouter::HTTP
  9:     def initialize(access_token: nil, request_timeout: nil, uri_base: nil, extra_headers: {})
 10:       OpenRouter.configuration.access_token = access_token if access_token
 11:       OpenRouter.configuration.request_timeout = request_timeout if request_timeout
 12:       OpenRouter.configuration.uri_base = uri_base if uri_base
 13:       OpenRouter.configuration.extra_headers = extra_headers if extra_headers.any?
 14:       yield(OpenRouter.configuration) if block_given?
 15:     end
 16:     def configuration
 17:       OpenRouter.configuration
 18:     end
 19:     def complete(messages, model: "openrouter/auto", providers: [], transforms: [], tools: [], tool_choice: nil, response_format: nil, force_structured_output: nil, extras: {}, stream: nil)
 20:       parameters = { messages: }
 21:       if model.is_a?(String)
 22:         parameters[:model] = model
 23:       elsif model.is_a?(Array)
 24:         parameters[:models] = model
 25:         parameters[:route] = "fallback"
 26:       end
 27:       parameters[:provider] = { provider: { order: providers } } if providers.any?
 28:       parameters[:transforms] = transforms if transforms.any?
 29:       if tools.any?
 30:         warn_if_unsupported(model, :function_calling, "tool calling")
 31:         parameters[:tools] = serialize_tools(tools)
 32:         parameters[:tool_choice] = tool_choice if tool_choice
 33:       end
 34:       forced_extraction = false
 35:       if response_format
 36:         if force_structured_output.nil?
 37:           if model.is_a?(String) && model != "openrouter/auto" && !ModelRegistry.has_capability?(model, :structured_outputs)
 38:             warn "[OpenRouter] Model '#{model}' doesn't support native structured outputs. Automatically using forced extraction mode."
 39:             force_structured_output = true
 40:           else
 41:             force_structured_output = false
 42:           end
 43:         end
 44:         if force_structured_output
 45:           inject_schema_instructions!(parameters[:messages], response_format)
 46:           forced_extraction = true
 47:         else
 48:           warn_if_unsupported(model, :structured_outputs, "structured outputs")
 49:           parameters[:response_format] = serialize_response_format(response_format)
 50:         end
 51:       end
 52:       if messages_contain_images?(messages)
 53:         warn_if_unsupported(model, :vision, "vision/image processing")
 54:       end
 55:       parameters[:stream] = stream if stream
 56:       parameters.merge!(extras)
 57:       raw_response = post(path: "/chat/completions", parameters:)
 58:       raise ServerError, raw_response.dig("error", "message") if raw_response.presence&.dig("error", "message").present?
 59:       raise ServerError, "Empty response from OpenRouter. Might be worth retrying once or twice." if stream.blank? && raw_response.blank?
 60:       response = Response.new(raw_response, response_format: response_format, forced_extraction: forced_extraction)
 61:       if configuration.auto_heal_responses
 62:         response.client = self
 63:       end
 64:       response
 65:     end
 66:     def models
 67:       get(path: "/models")["data"]
 68:     end
 69:     def query_generation_stats(generation_id)
 70:       response = get(path: "/generation?id=#{generation_id}")
 71:       response["data"]
 72:     end
 73:     def select_model
 74:       ModelSelector.new
 75:     end
 76:     def smart_complete(messages, requirements: {}, optimization: :cost, **extras)
 77:       selector = ModelSelector.new.optimize_for(optimization)
 78:       selector = selector.require(*requirements[:capabilities]) if requirements[:capabilities]
 79:       if requirements[:max_cost] || requirements[:max_input_cost]
 80:         cost_opts = {}
 81:         cost_opts[:max_cost] = requirements[:max_cost] || requirements[:max_input_cost]
 82:         cost_opts[:max_output_cost] = requirements[:max_output_cost] if requirements[:max_output_cost]
 83:         selector = selector.within_budget(**cost_opts)
 84:       end
 85:       selector = selector.min_context(requirements[:min_context_length]) if requirements[:min_context_length]
 86:       if requirements[:providers]
 87:         case requirements[:providers]
 88:         when Hash
 89:           selector = selector.prefer_providers(*requirements[:providers][:prefer]) if requirements[:providers][:prefer]
 90:           selector = selector.require_providers(*requirements[:providers][:require]) if requirements[:providers][:require]
 91:           selector = selector.avoid_providers(*requirements[:providers][:avoid]) if requirements[:providers][:avoid]
 92:         when Array
 93:           selector = selector.prefer_providers(*requirements[:providers])
 94:         end
 95:       end
 96:       model = selector.choose
 97:       raise ModelSelectionError, "No model found matching requirements: #{requirements}" unless model
 98:       complete(messages, model:, **extras)
 99:     end
100:     def smart_complete_with_fallback(messages, requirements: {}, optimization: :cost, max_retries: 3, **extras)
101:       selector = ModelSelector.new.optimize_for(optimization)
102:       selector = selector.require(*requirements[:capabilities]) if requirements[:capabilities]
103:       if requirements[:max_cost] || requirements[:max_input_cost]
104:         cost_opts = {}
105:         cost_opts[:max_cost] = requirements[:max_cost] || requirements[:max_input_cost]
106:         cost_opts[:max_output_cost] = requirements[:max_output_cost] if requirements[:max_output_cost]
107:         selector = selector.within_budget(**cost_opts)
108:       end
109:       selector = selector.min_context(requirements[:min_context_length]) if requirements[:min_context_length]
110:       if requirements[:providers]
111:         case requirements[:providers]
112:         when Hash
113:           selector = selector.prefer_providers(*requirements[:providers][:prefer]) if requirements[:providers][:prefer]
114:           selector = selector.require_providers(*requirements[:providers][:require]) if requirements[:providers][:require]
115:           selector = selector.avoid_providers(*requirements[:providers][:avoid]) if requirements[:providers][:avoid]
116:         when Array
117:           selector = selector.prefer_providers(*requirements[:providers])
118:         end
119:       end
120:       fallback_models = selector.choose_with_fallbacks(limit: max_retries + 1)
121:       raise ModelSelectionError, "No models found matching requirements: #{requirements}" if fallback_models.empty?
122:       last_error = nil
123:       fallback_models.each do |model|
124:           return complete(messages, model:, **extras)
125:       rescue StandardError => e
126:           last_error = e
127:       end
128:       raise ModelSelectionError, "All fallback models failed. Last error: #{last_error&.message}"
129:     end
130:     private
131:     @@capability_warnings_shown = Set.new
132:     def warn_if_unsupported(model, capability, feature_name)
133:       return if model.is_a?(Array) || model == "openrouter/auto"
134:       unless ModelRegistry.has_capability?(model, capability)
135:         if configuration.strict_mode
136:           raise CapabilityError, "Model '#{model}' does not support #{feature_name} (missing :#{capability} capability). Enable non-strict mode to allow this request."
137:         else
138:           warning_key = "#{model}:#{capability}"
139:           return if @@capability_warnings_shown.include?(warning_key)
140:           warn "[OpenRouter Warning] Model '#{model}' may not support #{feature_name} (missing :#{capability} capability). The request will still be attempted."
141:           @@capability_warnings_shown << warning_key
142:         end
143:       end
144:     end
145:     def messages_contain_images?(messages)
146:       messages.any? do |msg|
147:         content = msg[:content] || msg["content"]
148:         if content.is_a?(Array)
149:           content.any? { |part| part.is_a?(Hash) && part[:type] == "image_url" }
150:         else
151:           false
152:         end
153:       end
154:     end
155:     def serialize_tools(tools)
156:       tools.map do |tool|
157:         case tool
158:         when Tool
159:           tool.to_h
160:         when Hash
161:           tool
162:         else
163:           raise ArgumentError, "Tools must be Tool objects or hashes"
164:         end
165:       end
166:     end
167:     def serialize_response_format(response_format)
168:       case response_format
169:       when Hash
170:         if response_format[:json_schema].is_a?(Schema)
171:           response_format.merge(json_schema: response_format[:json_schema].to_h)
172:         else
173:           response_format
174:         end
175:       when Schema
176:         {
177:           type: "json_schema",
178:           json_schema: response_format.to_h
179:         }
180:       else
181:         response_format
182:       end
183:     end
184:     def inject_schema_instructions!(messages, response_format)
185:       schema = extract_schema(response_format)
186:       return unless schema
187:       instruction_content = if schema.respond_to?(:get_format_instructions)
188:         schema.get_format_instructions
189:       else
190:         build_schema_instruction(schema)
191:       end
192:       messages << { role: "system", content: instruction_content }
193:     end
194:     def extract_schema(response_format)
195:       case response_format
196:       when Schema
197:         response_format
198:       when Hash
199:         if response_format[:json_schema].is_a?(Schema)
200:           response_format[:json_schema]
201:         elsif response_format[:json_schema].is_a?(Hash)
202:           response_format[:json_schema]
203:         else
204:           response_format
205:         end
206:       end
207:     end
208:     def build_schema_instruction(schema)
209:       schema_json = schema.respond_to?(:to_h) ? schema.to_h.to_json : schema.to_json
210:       <<~INSTRUCTION
211:         You must respond with valid JSON matching this exact schema:
212:         ```json
213:         ```
214:         Rules:
215:         - Return ONLY the JSON object, no other text
216:         - Ensure all required fields are present
217:         - Match the exact data types specified
218:         - Follow any format constraints (email, date, etc.)
219:         - Do not include trailing commas or comments
220:       INSTRUCTION
221:     end
222:   end
223: end
</file>

<file path="lib/open_router/http.rb">
 1: module OpenRouter
 2:   module HTTP
 3:     def get(path:)
 4:       conn.get(uri(path:)) do |req|
 5:         req.headers = headers
 6:       end&.body
 7:     end
 8:     def post(path:, parameters:)
 9:       conn.post(uri(path:)) do |req|
10:         if parameters[:stream].respond_to?(:call)
11:           req.options.on_data = to_json_stream(user_proc: parameters[:stream])
12:           parameters[:stream] = true
13:         end
14:         req.headers = headers
15:         req.body = parameters.to_json
16:       end&.body
17:     end
18:     def multipart_post(path:, parameters: nil)
19:       conn(multipart: true).post(uri(path:)) do |req|
20:         req.headers = headers.merge({ "Content-Type" => "multipart/form-data" })
21:         req.body = multipart_parameters(parameters)
22:       end&.body
23:     end
24:     def delete(path:)
25:       conn.delete(uri(path:)) do |req|
26:         req.headers = headers
27:       end&.body
28:     end
29:     private
30:     def to_json_stream(user_proc:)
31:       proc do |chunk, _|
32:         chunk.scan(/(?:data|error): (\{.*\})/i).flatten.each do |data|
33:           user_proc.call(JSON.parse(data))
34:         rescue JSON::ParserError
35:         end
36:       end
37:     end
38:     def conn(multipart: false)
39:       Faraday.new do |f|
40:         f.options[:timeout] = OpenRouter.configuration.request_timeout
41:         f.request(:multipart) if multipart
42:         f.use MiddlewareErrors if @log_errors
43:         f.response :raise_error
44:         f.response :json
45:         OpenRouter.configuration.faraday_config&.call(f)
46:       end
47:     end
48:     def uri(path:)
49:       File.join(OpenRouter.configuration.uri_base, OpenRouter.configuration.api_version, path)
50:     end
51:     def headers
52:       {
53:         "Authorization" => "Bearer #{OpenRouter.configuration.access_token}",
54:         "Content-Type" => "application/json",
55:         "X-Title" => "OpenRouter Ruby Client",
56:         "HTTP-Referer" => "https://github.com/OlympiaAI/open_router"
57:       }.merge(OpenRouter.configuration.extra_headers)
58:     end
59:     def multipart_parameters(parameters)
60:       parameters&.transform_values do |value|
61:         next value unless value.is_a?(File)
62:         Faraday::UploadIO.new(value, "", value.path)
63:       end
64:     end
65:   end
66: end
</file>

<file path="lib/open_router/model_registry.rb">
  1: require "json"
  2: require "net/http"
  3: require "uri"
  4: require "tmpdir"
  5: require "fileutils"
  6: module OpenRouter
  7:   class ModelRegistryError < Error; end
  8:   class ModelRegistry
  9:     API_BASE = "https://openrouter.ai/api/v1"
 10:     CACHE_DIR = File.join(Dir.tmpdir, 'openrouter_cache')
 11:     CACHE_DATA_FILE = File.join(CACHE_DIR, 'models_data.json')
 12:     CACHE_METADATA_FILE = File.join(CACHE_DIR, 'cache_metadata.json')
 13:     class << self
 14:       def fetch_models_from_api
 15:         uri = URI("#{API_BASE}/models")
 16:         response = Net::HTTP.get_response(uri)
 17:         raise ModelRegistryError, "Failed to fetch models from OpenRouter API: #{response.message}" unless response.code == "200"
 18:         JSON.parse(response.body)
 19:       rescue JSON::ParserError => e
 20:         raise ModelRegistryError, "Failed to parse OpenRouter API response: #{e.message}"
 21:       rescue StandardError => e
 22:         raise ModelRegistryError, "Network error fetching models: #{e.message}"
 23:       end
 24:       def ensure_cache_dir
 25:         FileUtils.mkdir_p(CACHE_DIR) unless Dir.exist?(CACHE_DIR)
 26:       end
 27:       def cache_stale?
 28:         return true unless File.exist?(CACHE_METADATA_FILE)
 29:         begin
 30:           metadata = JSON.parse(File.read(CACHE_METADATA_FILE))
 31:           cache_time = metadata['cached_at']
 32:           ttl = OpenRouter.configuration.cache_ttl
 33:           return true unless cache_time
 34:           Time.now.to_i - cache_time.to_i > ttl
 35:         rescue JSON::ParserError, StandardError
 36:           true
 37:         end
 38:       end
 39:       def write_cache_with_timestamp(models_data)
 40:         ensure_cache_dir
 41:         File.write(CACHE_DATA_FILE, JSON.pretty_generate(models_data))
 42:         metadata = {
 43:           'cached_at' => Time.now.to_i,
 44:           'version' => '1.0',
 45:           'source' => 'openrouter_api'
 46:         }
 47:         File.write(CACHE_METADATA_FILE, JSON.pretty_generate(metadata))
 48:       end
 49:       def read_cache_if_fresh
 50:         return nil if cache_stale?
 51:         return nil unless File.exist?(CACHE_DATA_FILE)
 52:         JSON.parse(File.read(CACHE_DATA_FILE))
 53:       rescue JSON::ParserError
 54:         nil
 55:       end
 56:       def clear_cache!
 57:         FileUtils.rm_rf(CACHE_DIR) if Dir.exist?(CACHE_DIR)
 58:         @processed_models = nil
 59:         @all_models = nil
 60:       end
 61:       def refresh!
 62:         clear_cache!
 63:         fetch_and_cache_models
 64:       end
 65:       def fetch_and_cache_models
 66:         cached_data = read_cache_if_fresh
 67:         if cached_data
 68:           api_data = cached_data
 69:         else
 70:           api_data = fetch_models_from_api
 71:           write_cache_with_timestamp(api_data)
 72:         end
 73:         @processed_models = process_api_models(api_data["data"])
 74:       end
 75:       def find_original_model_data(model_id)
 76:         cached_data = read_cache_if_fresh
 77:         if cached_data
 78:           api_data = cached_data
 79:         else
 80:           api_data = fetch_models_from_api
 81:           write_cache_with_timestamp(api_data)
 82:         end
 83:         raw_models = api_data["data"] || []
 84:         raw_models.find { |model| model["id"] == model_id }
 85:       end
 86:       def process_api_models(api_models)
 87:         models = {}
 88:         api_models.each do |model_data|
 89:           model_id = model_data["id"]
 90:           models[model_id] = {
 91:             name: model_data["name"],
 92:             cost_per_1k_tokens: {
 93:               input: model_data["pricing"]["prompt"].to_f,
 94:               output: model_data["pricing"]["completion"].to_f
 95:             },
 96:             context_length: model_data["context_length"],
 97:             capabilities: extract_capabilities(model_data),
 98:             description: model_data["description"],
 99:             supported_parameters: model_data["supported_parameters"] || [],
100:             architecture: model_data["architecture"],
101:             performance_tier: determine_performance_tier(model_data),
102:             fallbacks: determine_fallbacks(model_id, model_data),
103:             created_at: model_data["created"]
104:           }
105:         end
106:         models
107:       end
108:       def extract_capabilities(model_data)
109:         capabilities = [:chat]
110:         supported_params = model_data["supported_parameters"] || []
111:         capabilities << :function_calling if supported_params.include?("tools") && supported_params.include?("tool_choice")
112:         capabilities << :structured_outputs if supported_params.include?("structured_outputs") || supported_params.include?("response_format")
113:         architecture = model_data["architecture"] || {}
114:         input_modalities = architecture["input_modalities"] || []
115:         capabilities << :vision if input_modalities.include?("image")
116:         context_length = model_data["context_length"] || 0
117:         capabilities << :long_context if context_length > 100_000
118:         capabilities
119:       end
120:       def determine_performance_tier(model_data)
121:         input_cost = model_data["pricing"]["prompt"].to_f
122:         if input_cost > 0.00001
123:           :premium
124:         else
125:           :standard
126:         end
127:       end
128:       def determine_fallbacks(_model_id, _model_data)
129:         []
130:       end
131:       def find_best_model(requirements = {})
132:         candidates = models_meeting_requirements(requirements)
133:         return nil if candidates.empty?
134:         if requirements[:pick_newer]
135:           candidates.max_by { |_, specs| specs[:created_at] }
136:         else
137:           candidates.min_by { |_, specs| calculate_model_cost(specs, requirements) }
138:         end
139:       end
140:       def models_meeting_requirements(requirements = {})
141:         all_models.select do |_model, specs|
142:           meets_requirements?(specs, requirements)
143:         end
144:       end
145:       def get_fallbacks(model)
146:         model_info = get_model_info(model)
147:         model_info ? model_info[:fallbacks] || [] : []
148:       end
149:       def model_exists?(model)
150:         all_models.key?(model)
151:       end
152:       def has_capability?(model, capability)
153:         model_info = get_model_info(model)
154:         return false unless model_info
155:         model_info[:capabilities].include?(capability)
156:       end
157:       def get_model_info(model)
158:         all_models[model]
159:       end
160:       def all_models
161:         @all_models ||= fetch_and_cache_models
162:       end
163:       def calculate_estimated_cost(model, input_tokens: 0, output_tokens: 0)
164:         model_info = get_model_info(model)
165:         return 0 unless model_info
166:         input_cost = (input_tokens / 1000.0) * model_info[:cost_per_1k_tokens][:input]
167:         output_cost = (output_tokens / 1000.0) * model_info[:cost_per_1k_tokens][:output]
168:         input_cost + output_cost
169:       end
170:       private
171:       def meets_requirements?(specs, requirements)
172:         if requirements[:capabilities]
173:           required_caps = Array(requirements[:capabilities])
174:           return false unless required_caps.all? { |cap| specs[:capabilities].include?(cap) }
175:         end
176:         return false if requirements[:max_input_cost] && (specs[:cost_per_1k_tokens][:input] > requirements[:max_input_cost])
177:         return false if requirements[:max_output_cost] && (specs[:cost_per_1k_tokens][:output] > requirements[:max_output_cost])
178:         return false if requirements[:min_context_length] && (specs[:context_length] < requirements[:min_context_length])
179:         if requirements[:performance_tier]
180:           required_tier = requirements[:performance_tier]
181:           model_tier = specs[:performance_tier]
182:           case required_tier
183:           when :premium
184:             return false unless model_tier == :premium
185:           when :standard
186:             return false unless %i[standard premium].include?(model_tier)
187:           end
188:         end
189:         if requirements[:released_after_date]
190:           required_date = requirements[:released_after_date]
191:           model_timestamp = specs[:created_at]
192:           required_timestamp = case required_date
193:                                when Date
194:                                  required_date.to_time.to_i
195:                                when Time
196:                                  required_date.to_i
197:                                when Integer
198:                                  required_date
199:                                else
200:                                  return false
201:                                end
202:           return false if model_timestamp < required_timestamp
203:         end
204:         true
205:       end
206:       def calculate_model_cost(specs, _requirements)
207:         specs[:cost_per_1k_tokens][:input]
208:       end
209:     end
210:   end
211: end
</file>

<file path="lib/open_router/model_selector.rb">
  1: module OpenRouter
  2:   class ModelSelectionError < Error; end
  3:   class ModelSelector
  4:     STRATEGIES = {
  5:       cost: { sort_by: :cost, pick_newer: false },
  6:       performance: { sort_by: :performance, pick_newer: false },
  7:       latest: { sort_by: :date, pick_newer: true },
  8:       context: { sort_by: :context_length, pick_newer: false }
  9:     }.freeze
 10:     def initialize(requirements: {}, strategy: :cost, provider_preferences: {}, fallback_options: {})
 11:       @requirements = requirements.dup
 12:       @strategy = strategy
 13:       @provider_preferences = provider_preferences.dup
 14:       @fallback_options = fallback_options.dup
 15:     end
 16:     def optimize_for(strategy)
 17:       raise ArgumentError, "Unknown strategy: #{strategy}. Available: #{STRATEGIES.keys.join(", ")}" unless STRATEGIES.key?(strategy)
 18:       new_requirements = @requirements.dup
 19:       case strategy
 20:       when :performance
 21:         new_requirements[:performance_tier] = :premium
 22:       when :latest
 23:         new_requirements[:pick_newer] = true
 24:       end
 25:       self.class.new(
 26:         requirements: new_requirements,
 27:         strategy:,
 28:         provider_preferences: @provider_preferences,
 29:         fallback_options: @fallback_options
 30:       )
 31:     end
 32:     def require(*capabilities)
 33:       new_requirements = @requirements.dup
 34:       new_requirements[:capabilities] = Array(new_requirements[:capabilities]) + capabilities
 35:       new_requirements[:capabilities].uniq!
 36:       self.class.new(
 37:         requirements: new_requirements,
 38:         strategy: @strategy,
 39:         provider_preferences: @provider_preferences,
 40:         fallback_options: @fallback_options
 41:       )
 42:     end
 43:     def within_budget(max_cost: nil, max_output_cost: nil)
 44:       new_requirements = @requirements.dup
 45:       new_requirements[:max_input_cost] = max_cost if max_cost
 46:       new_requirements[:max_output_cost] = max_output_cost if max_output_cost
 47:       self.class.new(
 48:         requirements: new_requirements,
 49:         strategy: @strategy,
 50:         provider_preferences: @provider_preferences,
 51:         fallback_options: @fallback_options
 52:       )
 53:     end
 54:     def min_context(tokens)
 55:       new_requirements = @requirements.dup
 56:       new_requirements[:min_context_length] = tokens
 57:       self.class.new(
 58:         requirements: new_requirements,
 59:         strategy: @strategy,
 60:         provider_preferences: @provider_preferences,
 61:         fallback_options: @fallback_options
 62:       )
 63:     end
 64:     def newer_than(date)
 65:       new_requirements = @requirements.dup
 66:       new_requirements[:released_after_date] = date
 67:       self.class.new(
 68:         requirements: new_requirements,
 69:         strategy: @strategy,
 70:         provider_preferences: @provider_preferences,
 71:         fallback_options: @fallback_options
 72:       )
 73:     end
 74:     def prefer_providers(*providers)
 75:       new_provider_preferences = @provider_preferences.dup
 76:       new_provider_preferences[:preferred] = providers.flatten
 77:       self.class.new(
 78:         requirements: @requirements,
 79:         strategy: @strategy,
 80:         provider_preferences: new_provider_preferences,
 81:         fallback_options: @fallback_options
 82:       )
 83:     end
 84:     def require_providers(*providers)
 85:       new_provider_preferences = @provider_preferences.dup
 86:       new_provider_preferences[:required] = providers.flatten
 87:       self.class.new(
 88:         requirements: @requirements,
 89:         strategy: @strategy,
 90:         provider_preferences: new_provider_preferences,
 91:         fallback_options: @fallback_options
 92:       )
 93:     end
 94:     def avoid_providers(*providers)
 95:       new_provider_preferences = @provider_preferences.dup
 96:       new_provider_preferences[:avoided] = providers.flatten
 97:       self.class.new(
 98:         requirements: @requirements,
 99:         strategy: @strategy,
100:         provider_preferences: new_provider_preferences,
101:         fallback_options: @fallback_options
102:       )
103:     end
104:     def avoid_patterns(*patterns)
105:       new_provider_preferences = @provider_preferences.dup
106:       new_provider_preferences[:avoided_patterns] = patterns.flatten
107:       self.class.new(
108:         requirements: @requirements,
109:         strategy: @strategy,
110:         provider_preferences: new_provider_preferences,
111:         fallback_options: @fallback_options
112:       )
113:     end
114:     def with_fallbacks(max: 3, strategy: :similar)
115:       new_fallback_options = { max_fallbacks: max, strategy: }
116:       self.class.new(
117:         requirements: @requirements,
118:         strategy: @strategy,
119:         provider_preferences: @provider_preferences,
120:         fallback_options: new_fallback_options
121:       )
122:     end
123:     def choose(return_specs: false)
124:       candidates = filter_by_providers(ModelRegistry.models_meeting_requirements(@requirements))
125:       return nil if candidates.empty?
126:       best_match = apply_strategy_sorting(candidates)
127:       return nil unless best_match
128:       return_specs ? best_match : best_match.first
129:     end
130:     def choose_with_fallbacks(limit: 3)
131:       candidates = filter_by_providers(ModelRegistry.models_meeting_requirements(@requirements))
132:       return [] if candidates.empty?
133:       sorted_candidates = apply_strategy_sorting_all(candidates)
134:       sorted_candidates.first(limit).map(&:first)
135:     end
136:     def choose_with_fallback
137:       result = choose
138:       return result if result
139:       fallback_requirements = @requirements.dup
140:       %i[
141:         released_after_date
142:         performance_tier
143:         max_output_cost
144:         min_context_length
145:         max_input_cost
146:       ].each do |requirement|
147:         next unless fallback_requirements.key?(requirement)
148:         fallback_requirements.delete(requirement)
149:         candidates = filter_by_providers(ModelRegistry.models_meeting_requirements(fallback_requirements))
150:         unless candidates.empty?
151:           result = apply_strategy_sorting(candidates)
152:           return result&.first
153:         end
154:       end
155:       if fallback_requirements[:capabilities]
156:         basic_requirements = { capabilities: fallback_requirements[:capabilities] }
157:         candidates = filter_by_providers(ModelRegistry.models_meeting_requirements(basic_requirements))
158:         result = apply_strategy_sorting(candidates) unless candidates.empty?
159:         return result&.first if result
160:       end
161:       all_candidates = filter_by_providers(ModelRegistry.all_models)
162:       return nil if all_candidates.empty?
163:       all_candidates.min_by { |_, specs| specs[:cost_per_1k_tokens][:input] }&.first
164:     end
165:     def selection_criteria
166:       {
167:         requirements: deep_dup(@requirements),
168:         strategy: @strategy,
169:         provider_preferences: deep_dup(@provider_preferences),
170:         fallback_options: deep_dup(@fallback_options)
171:       }
172:     end
173:     def estimate_cost(model, input_tokens: 1000, output_tokens: 1000)
174:       ModelRegistry.calculate_estimated_cost(model, input_tokens:, output_tokens:)
175:     end
176:     private
177:     def deep_dup(obj)
178:       case obj
179:       when Hash
180:         obj.transform_values { |v| deep_dup(v) }
181:       when Array
182:         obj.map { |item| deep_dup(item) }
183:       else
184:         obj
185:       end
186:     end
187:     def filter_by_providers(candidates)
188:       return candidates if @provider_preferences.empty?
189:       filtered = candidates.dup
190:       if @provider_preferences[:required]
191:         required_providers = @provider_preferences[:required]
192:         filtered = filtered.select do |model_id, _|
193:           provider = extract_provider_from_model_id(model_id)
194:           required_providers.include?(provider)
195:         end
196:       end
197:       if @provider_preferences[:avoided]
198:         avoided_providers = @provider_preferences[:avoided]
199:         filtered = filtered.reject do |model_id, _|
200:           provider = extract_provider_from_model_id(model_id)
201:           avoided_providers.include?(provider)
202:         end
203:       end
204:       if @provider_preferences[:avoided_patterns]
205:         patterns = @provider_preferences[:avoided_patterns]
206:         filtered = filtered.reject do |model_id, _|
207:           patterns.any? { |pattern| File.fnmatch(pattern, model_id) }
208:         end
209:       end
210:       filtered
211:     end
212:     def extract_provider_from_model_id(model_id)
213:       model_id.split("/").first
214:     end
215:     def apply_strategy_sorting(candidates)
216:       case @strategy
217:       when :cost
218:         candidates.min_by { |_, specs| specs[:cost_per_1k_tokens][:input] }
219:       when :performance
220:         candidates.min_by do |_, specs|
221:           [specs[:performance_tier] == :premium ? 0 : 1, specs[:cost_per_1k_tokens][:input]]
222:         end
223:       when :latest
224:         candidates.max_by { |_, specs| specs[:created_at] }
225:       when :context
226:         candidates.max_by { |_, specs| specs[:context_length] }
227:       else
228:         candidates.min_by { |_, specs| specs[:cost_per_1k_tokens][:input] }
229:       end
230:     end
231:     def apply_strategy_sorting_all(candidates)
232:       case @strategy
233:       when :cost
234:         candidates.sort_by { |_, specs| specs[:cost_per_1k_tokens][:input] }
235:       when :performance
236:         candidates.sort_by do |_, specs|
237:           [specs[:performance_tier] == :premium ? 0 : 1, specs[:cost_per_1k_tokens][:input]]
238:         end
239:       when :latest
240:         candidates.sort_by { |_, specs| -specs[:created_at] }
241:       when :context
242:         candidates.sort_by { |_, specs| -specs[:context_length] }
243:       else
244:         candidates.sort_by { |_, specs| specs[:cost_per_1k_tokens][:input] }
245:       end
246:     end
247:   end
248: end
</file>

<file path="lib/open_router/response.rb">
  1: require "json"
  2: module OpenRouter
  3:   class StructuredOutputError < Error; end
  4:   class Response
  5:     attr_reader :raw_response, :response_format
  6:     attr_accessor :client
  7:     def initialize(raw_response, response_format: nil, forced_extraction: false)
  8:       @raw_response = raw_response.is_a?(Hash) ? raw_response.with_indifferent_access : {}
  9:       @response_format = response_format
 10:       @forced_extraction = forced_extraction
 11:       @client = nil
 12:     end
 13:     def [](key)
 14:       @raw_response[key]
 15:     end
 16:     def dig(*keys)
 17:       @raw_response.dig(*keys)
 18:     end
 19:     def fetch(key, default = nil)
 20:       @raw_response.fetch(key, default)
 21:     end
 22:     def key?(key)
 23:       @raw_response.key?(key)
 24:     end
 25:     def to_h
 26:       @raw_response.to_h
 27:     end
 28:     def to_json(*args)
 29:       @raw_response.to_json(*args)
 30:     end
 31:     def tool_calls
 32:       @tool_calls ||= parse_tool_calls
 33:     end
 34:     def has_tool_calls?
 35:       !tool_calls.empty?
 36:     end
 37:     def to_message
 38:       if has_tool_calls?
 39:         {
 40:           role: "assistant",
 41:           content:,
 42:           tool_calls: raw_tool_calls
 43:         }
 44:       else
 45:         {
 46:           role: "assistant",
 47:           content:
 48:         }
 49:       end
 50:     end
 51:     def structured_output(mode: :strict, auto_heal: nil)
 52:       unless [:strict, :gentle].include?(mode)
 53:         raise ArgumentError, "Invalid mode: #{mode}. Must be :strict or :gentle."
 54:       end
 55:       return nil unless structured_output_expected? && has_content?
 56:       case mode
 57:       when :strict
 58:         should_heal = auto_heal.nil? ?
 59:           (@client && @client.configuration.auto_heal_responses) :
 60:           auto_heal
 61:         result = parse_and_heal_structured_output(auto_heal: should_heal)
 62:         if result && !should_heal && validation_available?
 63:           schema_obj = extract_schema_from_response_format
 64:           if schema_obj && !schema_obj.validate(result)
 65:             validation_errors = schema_obj.validation_errors(result)
 66:             raise StructuredOutputError, "Schema validation failed: #{validation_errors.join(', ')}"
 67:           end
 68:         end
 69:         @structured_output ||= result
 70:       when :gentle
 71:         content_to_parse = @forced_extraction ? extract_json_from_text(content) : content
 72:         return nil if content_to_parse.nil?
 73:         begin
 74:           JSON.parse(content_to_parse)
 75:         rescue JSON::ParserError
 76:           nil
 77:         end
 78:       end
 79:     end
 80:     def valid_structured_output?
 81:       return true unless structured_output_expected?
 82:       return true unless validation_available?
 83:       schema_obj = extract_schema_from_response_format
 84:       return true unless schema_obj
 85:       schema_obj.validate(structured_output)
 86:     end
 87:     def validation_errors
 88:       return [] unless structured_output_expected?
 89:       return [] unless validation_available?
 90:       schema_obj = extract_schema_from_response_format
 91:       return [] unless schema_obj
 92:       schema_obj.validation_errors(structured_output)
 93:     end
 94:     def content
 95:       choices.first&.dig("message", "content")
 96:     end
 97:     def choices
 98:       @raw_response["choices"] || []
 99:     end
100:     def usage
101:       @raw_response["usage"]
102:     end
103:     def id
104:       @raw_response["id"]
105:     end
106:     def model
107:       @raw_response["model"]
108:     end
109:     def created
110:       @raw_response["created"]
111:     end
112:     def object
113:       @raw_response["object"]
114:     end
115:     def has_content?
116:       !content.nil? && !content.empty?
117:     end
118:     def error?
119:       @raw_response.key?("error")
120:     end
121:     def error_message
122:       @raw_response.dig("error", "message")
123:     end
124:     private
125:     def parse_tool_calls
126:       tool_calls_data = choices.first&.dig("message", "tool_calls")
127:       return [] unless tool_calls_data.is_a?(Array)
128:       tool_calls_data.map { |tc| ToolCall.new(tc) }
129:     rescue StandardError => e
130:       raise ToolCallError, "Failed to parse tool calls: #{e.message}"
131:     end
132:     def raw_tool_calls
133:       choices.first&.dig("message", "tool_calls") || []
134:     end
135:     def parse_and_heal_structured_output(auto_heal: false)
136:       return nil unless structured_output_expected?
137:       return nil unless has_content?
138:       content_to_parse = @forced_extraction ? extract_json_from_text(content) : content
139:       if auto_heal && @client
140:         healing_content = @forced_extraction && content_to_parse.nil? ? content : (content_to_parse || content)
141:         heal_structured_response(healing_content, extract_schema_from_response_format)
142:       else
143:         return nil if content_to_parse.nil?
144:         begin
145:           JSON.parse(content_to_parse)
146:         rescue JSON::ParserError => e
147:           raise StructuredOutputError, "Failed to parse structured output: #{e.message}"
148:         end
149:       end
150:     end
151:     def extract_json_from_text(text)
152:       return nil if text.nil? || text.empty?
153:       if text.include?("```")
154:         json_match = text.match(/```(?:json)?\s*\n?(.*?)\n?```/m)
155:         if json_match
156:           candidate = json_match[1].strip
157:           return candidate unless candidate.empty?
158:         end
159:       end
160:       begin
161:         JSON.parse(text)
162:         return text
163:       rescue JSON::ParserError
164:         json_match = text.match(/(\{.*\}|\[.*\])/m)
165:         return json_match[1] if json_match
166:       end
167:       nil
168:     end
169:     def structured_output_expected?
170:       return false unless @response_format
171:       if @response_format.is_a?(Schema)
172:         true
173:       elsif @response_format.is_a?(Hash) && @response_format[:type] == "json_schema"
174:         true
175:       else
176:         false
177:       end
178:     end
179:     def validation_available?
180:       defined?(JSON::Validator)
181:     end
182:     def extract_schema_from_response_format
183:       case @response_format
184:       when Schema
185:         @response_format
186:       when Hash
187:         schema_def = @response_format[:json_schema]
188:         if schema_def.is_a?(Schema)
189:           schema_def
190:         elsif schema_def.is_a?(Hash) && schema_def[:schema]
191:           Schema.new(
192:             schema_def[:name] || "response",
193:             schema_def[:schema],
194:             strict: schema_def[:strict] || true
195:           )
196:         end
197:       end
198:     end
199:     def heal_structured_response(content, schema)
200:       max_attempts = @client.configuration.max_heal_attempts
201:       healer_model = @client.configuration.healer_model
202:       attempts = 0
203:       current_content = content
204:       loop do
205:         begin
206:           json = JSON.parse(current_content)
207:           if schema&.respond_to?(:validate) && validation_available?
208:             if schema.validate(json)
209:               return json
210:             else
211:               validation_errors = schema.validation_errors(json)
212:               if attempts >= max_attempts
213:                 error_details = validation_errors.any? ? validation_errors.join(', ') : 'Schema validation failed'
214:                 raise StructuredOutputError, "Failed to pass schema validation after #{max_attempts} healing attempts. Last errors: #{error_details}"
215:               end
216:               attempts += 1
217:               error_reason = "Schema validation failed with errors: #{validation_errors.join('; ')}"
218:               current_content = fix_with_healer_model(current_content, schema, healer_model, error_reason)
219:             end
220:           else
221:             return json
222:           end
223:         rescue JSON::ParserError => e
224:           if attempts >= max_attempts
225:             raise StructuredOutputError, "Failed to parse structured output after #{max_attempts} healing attempts: #{e.message}"
226:           end
227:           attempts += 1
228:           current_content = fix_with_healer_model(current_content, schema, healer_model, "Invalid JSON: #{e.message}")
229:         end
230:       end
231:     end
232:     def fix_with_healer_model(content, schema, healer_model, error_reason)
233:       if schema
234:         fix_prompt = build_schema_healing_prompt(content, schema, error_reason)
235:       else
236:         fix_prompt = build_json_healing_prompt(content, error_reason)
237:       end
238:       begin
239:         healing_response = @client.complete(
240:           [{ role: "user", content: fix_prompt }],
241:           model: healer_model,
242:           extras: { max_tokens: 2000, temperature: 0 }
243:         )
244:         healing_response.content
245:       rescue => e
246:         content
247:       end
248:     end
249:     def build_json_healing_prompt(content, error_reason)
250:       <<~PROMPT
251:         The following content has a JSON parsing error:
252:         Content to fix:
253:         Please fix this content to be valid JSON. Return ONLY the fixed JSON, no explanations or additional text.
254:       PROMPT
255:     end
256:     def build_schema_healing_prompt(content, schema, error_reason)
257:       schema_json = schema.respond_to?(:to_h) ? schema.to_h.to_json : schema.to_json
258:       <<~PROMPT
259:         The following JSON content is invalid because it failed to validate against the provided JSON Schema.
260:         Validation Errors:
261:         Original Content to Fix:
262:         ```json
263:         ```
264:         Required JSON Schema:
265:         ```json
266:         ```
267:         Please correct the content to produce a valid JSON object that strictly conforms to the schema.
268:         Return ONLY the fixed, raw JSON object, without any surrounding text or explanations.
269:       PROMPT
270:     end
271:   end
272: end
</file>

<file path="lib/open_router/schema.rb">
  1: module OpenRouter
  2:   class SchemaValidationError < Error; end
  3:   class Schema
  4:     attr_reader :name, :strict, :schema
  5:     def initialize(name, schema_definition = {}, strict: true)
  6:       @name = name
  7:       @strict = strict
  8:       raise ArgumentError, "Schema definition must be a hash" unless schema_definition.is_a?(Hash)
  9:       @schema = schema_definition
 10:       validate_schema!
 11:     end
 12:     def self.define(name, strict: true, &block)
 13:       builder = SchemaBuilder.new
 14:       builder.instance_eval(&block) if block_given?
 15:       new(name, builder.to_h, strict:)
 16:     end
 17:     def to_h
 18:       {
 19:         name: @name,
 20:         strict: @strict,
 21:         schema: @schema
 22:       }
 23:     end
 24:     def to_json(*args)
 25:       to_h.to_json(*args)
 26:     end
 27:     def validate(data)
 28:       return true unless validation_available?
 29:       JSON::Validator.validate(@schema, data)
 30:     end
 31:     def validation_errors(data)
 32:       return [] unless validation_available?
 33:       JSON::Validator.fully_validate(@schema, data)
 34:     end
 35:     def validation_available?
 36:       !!defined?(JSON::Validator)
 37:     end
 38:     private
 39:     def validate_schema!
 40:       raise ArgumentError, "Schema name is required" if @name.nil? || @name.empty?
 41:       raise ArgumentError, "Schema must be a hash" unless @schema.is_a?(Hash)
 42:     end
 43:     class SchemaBuilder
 44:       def initialize
 45:         @schema = {
 46:           type: "object",
 47:           properties: {},
 48:           required: []
 49:         }
 50:         @strict_mode = true
 51:         @schema[:additionalProperties] = false
 52:       end
 53:       def strict(value = true)
 54:         @strict_mode = value
 55:         additional_properties(!value) if value
 56:       end
 57:       def additional_properties(allowed = true)
 58:         @schema[:additionalProperties] = allowed
 59:       end
 60:       def no_additional_properties
 61:         additional_properties(false)
 62:       end
 63:       def property(name, type, required: false, description: nil, **options)
 64:         prop_def = { type: type.to_s }
 65:         prop_def[:description] = description if description
 66:         prop_def.merge!(options)
 67:         @schema[:properties][name] = prop_def
 68:         mark_required(name) if required
 69:       end
 70:       def string(name, required: false, description: nil, **options)
 71:         property(name, :string, required:, description:, **options)
 72:       end
 73:       def integer(name, required: false, description: nil, **options)
 74:         property(name, :integer, required:, description:, **options)
 75:       end
 76:       def number(name, required: false, description: nil, **options)
 77:         property(name, :number, required:, description:, **options)
 78:       end
 79:       def boolean(name, required: false, description: nil, **options)
 80:         property(name, :boolean, required:, description:, **options)
 81:       end
 82:       def array(name, required: false, description: nil, items: nil, &block)
 83:         array_def = { type: "array" }
 84:         array_def[:description] = description if description
 85:         if items
 86:           array_def[:items] = items
 87:         elsif block_given?
 88:           items_builder = ItemsBuilder.new
 89:           items_builder.instance_eval(&block)
 90:           array_def[:items] = items_builder.to_h
 91:         end
 92:         @schema[:properties][name] = array_def
 93:         mark_required(name) if required
 94:       end
 95:       def object(name, required: false, description: nil, &block)
 96:         object_def = {
 97:           type: "object",
 98:           properties: {},
 99:           required: []
100:         }
101:         object_def[:description] = description if description
102:         if block_given?
103:           object_builder = SchemaBuilder.new
104:           object_builder.instance_eval(&block)
105:           nested_schema = object_builder.to_h
106:           object_def[:properties] = nested_schema[:properties]
107:           object_def[:required] = nested_schema[:required]
108:           object_def[:additionalProperties] = nested_schema[:additionalProperties] if nested_schema.key?(:additionalProperties)
109:         end
110:         @schema[:properties][name] = object_def
111:         mark_required(name) if required
112:       end
113:       def required(*field_names)
114:         field_names.each { |name| mark_required(name) }
115:       end
116:       def to_h
117:         finalized_schema = @schema.dup
118:         if finalized_schema[:properties] && finalized_schema[:properties].any?
119:           all_properties = finalized_schema[:properties].keys.map(&:to_s)
120:           finalized_schema[:required] = all_properties
121:         end
122:         finalized_schema
123:       end
124:       private
125:       def mark_required(name)
126:         string_name = name.to_s
127:         @schema[:required] << string_name unless @schema[:required].include?(string_name)
128:       end
129:     end
130:     class ItemsBuilder
131:       def initialize
132:         @items = {}
133:       end
134:       def string(description: nil, **options)
135:         @items = { type: "string" }
136:         @items[:description] = description if description
137:         @items.merge!(options)
138:       end
139:       def integer(description: nil, **options)
140:         @items = { type: "integer" }
141:         @items[:description] = description if description
142:         @items.merge!(options)
143:       end
144:       def number(description: nil, **options)
145:         @items = { type: "number" }
146:         @items[:description] = description if description
147:         @items.merge!(options)
148:       end
149:       def boolean(description: nil, **options)
150:         @items = { type: "boolean" }
151:         @items[:description] = description if description
152:         @items.merge!(options)
153:       end
154:       def object(&block)
155:         @items = { type: "object", properties: {}, required: [], additionalProperties: false }
156:         return unless block_given?
157:           object_builder = SchemaBuilder.new
158:           object_builder.instance_eval(&block)
159:           nested_schema = object_builder.to_h
160:           @items[:properties] = nested_schema[:properties]
161:           @items[:required] = nested_schema[:required]
162:           @items[:additionalProperties] = nested_schema[:additionalProperties] if nested_schema.key?(:additionalProperties)
163:       end
164:       def to_h
165:         @items
166:       end
167:     end
168:   end
169: end
</file>

<file path="lib/open_router/tool_call.rb">
 1: require "json"
 2: module OpenRouter
 3:   class ToolCallError < Error; end
 4:   class ToolCall
 5:     attr_reader :id, :type, :function_name, :arguments_string
 6:     def initialize(tool_call_data)
 7:       @id = tool_call_data["id"]
 8:       @type = tool_call_data["type"]
 9:       raise ToolCallError, "Invalid tool call data: missing function" unless tool_call_data["function"]
10:         @function_name = tool_call_data["function"]["name"]
11:         @arguments_string = tool_call_data["function"]["arguments"]
12:     end
13:     def arguments
14:       @arguments ||= begin
15:         JSON.parse(@arguments_string)
16:       rescue JSON::ParserError => e
17:         raise ToolCallError, "Failed to parse tool call arguments: #{e.message}"
18:       end
19:     end
20:     def name
21:       @function_name
22:     end
23:     def execute(&block)
24:       raise ArgumentError, "Block required for tool execution" unless block_given?
25:       result = block.call(@function_name, arguments)
26:       ToolResult.new(self, result)
27:     end
28:     def to_message
29:       {
30:         role: "assistant",
31:         content: nil,
32:         tool_calls: [
33:           {
34:             id: @id,
35:             type: @type,
36:             function: {
37:               name: @function_name,
38:               arguments: @arguments_string
39:             }
40:           }
41:         ]
42:       }
43:     end
44:     def to_result_message(result)
45:       {
46:         role: "tool",
47:         tool_call_id: @id,
48:         name: @function_name,
49:         content: result.is_a?(String) ? result : result.to_json
50:       }
51:     end
52:     def to_h
53:       {
54:         id: @id,
55:         type: @type,
56:         function: {
57:           name: @function_name,
58:           arguments: @arguments_string
59:         }
60:       }
61:     end
62:     def to_json(*args)
63:       to_h.to_json(*args)
64:     end
65:   end
66:   class ToolResult
67:     attr_reader :tool_call, :result, :error
68:     def initialize(tool_call, result = nil, error = nil)
69:       @tool_call = tool_call
70:       @result = result
71:       @error = error
72:     end
73:     def success?
74:       @error.nil?
75:     end
76:     def failure?
77:       !success?
78:     end
79:     def to_message
80:       @tool_call.to_result_message(@error || @result)
81:     end
82:     def self.failure(tool_call, error)
83:       new(tool_call, nil, error)
84:     end
85:     def self.success(tool_call, result)
86:       new(tool_call, result, nil)
87:     end
88:   end
89: end
</file>

<file path="lib/open_router/tool.rb">
  1: module OpenRouter
  2:   class Tool
  3:     attr_reader :type, :function
  4:     def initialize(definition = {})
  5:       if definition.is_a?(Hash) && definition.key?(:function)
  6:         @type = definition[:type] || "function"
  7:         @function = definition[:function]
  8:       elsif definition.is_a?(Hash)
  9:         @type = "function"
 10:         @function = definition
 11:       else
 12:         raise ArgumentError, "Tool definition must be a hash"
 13:       end
 14:       validate_definition!
 15:     end
 16:     def self.define(&block)
 17:       builder = ToolBuilder.new
 18:       builder.instance_eval(&block) if block_given?
 19:       new(builder.to_h)
 20:     end
 21:     def to_h
 22:       {
 23:         type: @type,
 24:         function: @function
 25:       }
 26:     end
 27:     def to_json(*args)
 28:       to_h.to_json(*args)
 29:     end
 30:     def name
 31:       @function[:name]
 32:     end
 33:     def description
 34:       @function[:description]
 35:     end
 36:     def parameters
 37:       @function[:parameters]
 38:     end
 39:     private
 40:     def validate_definition!
 41:       raise ArgumentError, "Function must have a name" unless @function[:name]
 42:       raise ArgumentError, "Function must have a description" unless @function[:description]
 43:       raise ArgumentError, "Function parameters must be an object" if @function[:parameters] && @function[:parameters][:type] != "object"
 44:     end
 45:     class ToolBuilder
 46:       def initialize
 47:         @definition = {
 48:           name: nil,
 49:           description: nil,
 50:           parameters: {
 51:             type: "object",
 52:             properties: {},
 53:             required: []
 54:           }
 55:         }
 56:       end
 57:       def name(value)
 58:         @definition[:name] = value
 59:       end
 60:       def description(value)
 61:         @definition[:description] = value
 62:       end
 63:       def parameters(&block)
 64:         param_builder = ParametersBuilder.new(@definition[:parameters])
 65:         param_builder.instance_eval(&block) if block_given?
 66:       end
 67:       def to_h
 68:         @definition
 69:       end
 70:     end
 71:     class ParametersBuilder
 72:       def initialize(params_hash)
 73:         @params = params_hash
 74:       end
 75:       def string(name, required: false, description: nil, **options)
 76:         add_property(name, { type: "string", description: }.merge(options).compact)
 77:         mark_required(name) if required
 78:       end
 79:       def integer(name, required: false, description: nil, **options)
 80:         add_property(name, { type: "integer", description: }.merge(options).compact)
 81:         mark_required(name) if required
 82:       end
 83:       def number(name, required: false, description: nil, **options)
 84:         add_property(name, { type: "number", description: }.merge(options).compact)
 85:         mark_required(name) if required
 86:       end
 87:       def boolean(name, required: false, description: nil, **options)
 88:         add_property(name, { type: "boolean", description: }.merge(options).compact)
 89:         mark_required(name) if required
 90:       end
 91:       def array(name, required: false, description: nil, &block)
 92:         array_def = { type: "array", description: }.compact
 93:         if block_given?
 94:           items_builder = ItemsBuilder.new
 95:           items_builder.instance_eval(&block)
 96:           array_def[:items] = items_builder.to_h
 97:         end
 98:         add_property(name, array_def)
 99:         mark_required(name) if required
100:       end
101:       def object(name, required: false, description: nil, &block)
102:         object_def = {
103:           type: "object",
104:           description:,
105:           properties: {},
106:           required: []
107:         }.compact
108:         if block_given?
109:           object_builder = ParametersBuilder.new(object_def)
110:           object_builder.instance_eval(&block)
111:         end
112:         add_property(name, object_def)
113:         mark_required(name) if required
114:       end
115:       private
116:       def add_property(name, definition)
117:         @params[:properties][name] = definition
118:       end
119:       def mark_required(name)
120:         @params[:required] << name unless @params[:required].include?(name)
121:       end
122:     end
123:     class ItemsBuilder
124:       def initialize
125:         @items = {}
126:       end
127:       def string(description: nil, **options)
128:         @items = { type: "string", description: }.merge(options).compact
129:       end
130:       def integer(description: nil, **options)
131:         @items = { type: "integer", description: }.merge(options).compact
132:       end
133:       def number(description: nil, **options)
134:         @items = { type: "number", description: }.merge(options).compact
135:       end
136:       def boolean(description: nil, **options)
137:         @items = { type: "boolean", description: }.merge(options).compact
138:       end
139:       def to_h
140:         @items
141:       end
142:     end
143:   end
144: end
</file>

<file path="lib/open_router/version.rb">
1: module OpenRouter
2:   VERSION = "0.3.3"
3: end
</file>

<file path="lib/open_router.rb">
 1: require "faraday"
 2: require "faraday/multipart"
 3: module OpenRouter
 4:   class Error < StandardError; end
 5:   class ConfigurationError < Error; end
 6:   class CapabilityError < Error; end
 7: end
 8: require_relative "open_router/http"
 9: require_relative "open_router/tool"
10: require_relative "open_router/tool_call"
11: require_relative "open_router/schema"
12: require_relative "open_router/response"
13: require_relative "open_router/model_registry"
14: require_relative "open_router/model_selector"
15: require_relative "open_router/client"
16: require_relative "open_router/version"
17: module OpenRouter
18:   class Configuration
19:     attr_writer :access_token
20:     attr_accessor :api_version, :extra_headers, :faraday_config, :log_errors, :request_timeout, :uri_base
21:     attr_accessor :auto_heal_responses, :healer_model, :max_heal_attempts
22:     attr_accessor :cache_ttl
23:     attr_accessor :strict_mode
24:     DEFAULT_API_VERSION = "v1"
25:     DEFAULT_REQUEST_TIMEOUT = 120
26:     DEFAULT_URI_BASE = "https://openrouter.ai/api"
27:     DEFAULT_CACHE_TTL = 7 * 24 * 60 * 60
28:     def initialize
29:       self.access_token = nil
30:       self.api_version = DEFAULT_API_VERSION
31:       self.extra_headers = {}
32:       self.log_errors = false
33:       self.request_timeout = DEFAULT_REQUEST_TIMEOUT
34:       self.uri_base = DEFAULT_URI_BASE
35:       self.auto_heal_responses = false
36:       self.healer_model = "openai/gpt-4o-mini"
37:       self.max_heal_attempts = 2
38:       self.cache_ttl = ENV.fetch('OPENROUTER_CACHE_TTL', DEFAULT_CACHE_TTL).to_i
39:       self.strict_mode = ENV.fetch('OPENROUTER_STRICT_MODE', 'false').downcase == 'true'
40:     end
41:     def access_token
42:       return @access_token if @access_token
43:       raise ConfigurationError, "OpenRouter access token missing!"
44:     end
45:     def faraday(&block)
46:       self.faraday_config = block
47:     end
48:     def site_name=(value)
49:       @extra_headers["X-Title"] = value
50:     end
51:     def site_url=(value)
52:       @extra_headers["HTTP-Referer"] = value
53:     end
54:   end
55:   class << self
56:     attr_writer :configuration
57:   end
58:   def self.configuration
59:     @configuration ||= OpenRouter::Configuration.new
60:   end
61:   def self.configure
62:     yield(configuration)
63:   end
64: end
</file>

<file path="sig/open_router.rbs">
 1: module OpenRouter
 2:   class Client
 3:     include OpenRouter::HTTP
 4: 
 5:     def initialize: () { (OpenRouter::Configuration) -> void } -> void
 6: 
 7:     def complete: (
 8:       messages: Array[Hash[Symbol, String]],
 9:       ?model: String,
10:       ?providers: Array[String],
11:       ?transforms: Array[String],
12:       ?extras: Hash[Symbol, untyped],
13:       ?stream: Proc
14:     ) -> Hash[String, untyped]
15: 
16:     def models: () -> Array[Hash[String, untyped]]
17: 
18:     def query_generation_stats: (generation_id: String) -> Hash[String, untyped]
19:   end
20: end
</file>

<file path=".gitignore">
 1: .DS_Store
 2: /.DS_Store
 3: 
 4: .claude
 5: .cline
 6: CLAUDE.md
 7: /.repomix/
 8: 
 9: /.bundle/
10: /.yardoc
11: /_yardoc/
12: /coverage/
13: /doc/
14: /pkg/
15: /spec/reports/
16: /tmp/
17: 
18: # rspec failure tracking
19: .rspec_status
20: *.gem
21: .env
22: /lib/open_router/.api_key
</file>

<file path=".repomixignore">
1: # Add patterns to ignore here, one per line
2: # Example:
3: # *.log
4: # tmp/
5: .env
6: spec/
7: *.json
8: *.md
</file>

<file path=".rspec">
1: --format documentation
2: --color
3: --require spec_helper
</file>

<file path=".ruby-version">
1: 3.2.2
</file>

<file path="Gemfile">
 1: # frozen_string_literal: true
 2: 
 3: source "https://rubygems.org"
 4: 
 5: # Specify your gem's dependencies in open_router.gemspec
 6: gemspec
 7: 
 8: gem "activesupport", ">= 6.0"
 9: 
10: group :development, :test do
11:   gem "dotenv", ">= 2"
12:   gem "pry", ">= 0.14"
13:   gem "vcr", "~> 6.2"
14:   gem "webmock", "~> 3.19"
15:   gem "json-schema", "~> 4.0"
16: end
17: 
18: group :development do
19:   gem "rake", "~> 13.0"
20:   gem "rspec", "~> 3.0"
21:   gem "rubocop", "~> 1.21"
22:   gem "solargraph-rails", "~> 0.2.0.pre"
23:   gem "sorbet"
24:   gem "tapioca", require: false
25: end
</file>

<file path="Gemfile.lock">
  1: PATH
  2:   remote: .
  3:   specs:
  4:     open_router (0.3.3)
  5:       activesupport (>= 6.0)
  6:       dotenv (>= 2)
  7:       faraday (>= 1)
  8:       faraday-multipart (>= 1)
  9: 
 10: GEM
 11:   remote: https://rubygems.org/
 12:   specs:
 13:     activesupport (7.1.3.2)
 14:       base64
 15:       bigdecimal
 16:       concurrent-ruby (~> 1.0, >= 1.0.2)
 17:       connection_pool (>= 2.2.5)
 18:       drb
 19:       i18n (>= 1.6, < 2)
 20:       minitest (>= 5.1)
 21:       mutex_m
 22:       tzinfo (~> 2.0)
 23:     addressable (2.8.7)
 24:       public_suffix (>= 2.0.2, < 7.0)
 25:     ast (2.4.2)
 26:     backport (1.2.0)
 27:     base64 (0.2.0)
 28:     benchmark (0.3.0)
 29:     bigdecimal (3.1.7)
 30:     coderay (1.1.3)
 31:     concurrent-ruby (1.2.3)
 32:     connection_pool (2.4.1)
 33:     crack (1.0.0)
 34:       bigdecimal
 35:       rexml
 36:     diff-lcs (1.5.0)
 37:     dotenv (3.1.0)
 38:     drb (2.2.1)
 39:     e2mmap (0.1.0)
 40:     erubi (1.12.0)
 41:     faraday (2.7.10)
 42:       faraday-net_http (>= 2.0, < 3.1)
 43:       ruby2_keywords (>= 0.0.4)
 44:     faraday-multipart (1.0.4)
 45:       multipart-post (~> 2)
 46:     faraday-net_http (3.0.2)
 47:     hashdiff (1.2.0)
 48:     i18n (1.14.4)
 49:       concurrent-ruby (~> 1.0)
 50:     jaro_winkler (1.5.6)
 51:     json (2.6.3)
 52:     json-schema (4.3.1)
 53:       addressable (>= 2.8)
 54:     kramdown (2.4.0)
 55:       rexml
 56:     kramdown-parser-gfm (1.1.0)
 57:       kramdown (~> 2.0)
 58:     language_server-protocol (3.17.0.3)
 59:     method_source (1.0.0)
 60:     mini_portile2 (2.8.9)
 61:     minitest (5.22.3)
 62:     multipart-post (2.3.0)
 63:     mutex_m (0.2.0)
 64:     netrc (0.11.0)
 65:     nokogiri (1.16.4)
 66:       mini_portile2 (~> 2.8.2)
 67:       racc (~> 1.4)
 68:     parallel (1.23.0)
 69:     parser (3.2.2.3)
 70:       ast (~> 2.4.1)
 71:       racc
 72:     prism (0.24.0)
 73:     pry (0.14.2)
 74:       coderay (~> 1.1)
 75:       method_source (~> 1.0)
 76:     public_suffix (6.0.2)
 77:     racc (1.7.1)
 78:     rainbow (3.1.1)
 79:     rake (13.0.6)
 80:     rbi (0.1.10)
 81:       prism (>= 0.18.0, < 0.25)
 82:       sorbet-runtime (>= 0.5.9204)
 83:     rbs (2.8.4)
 84:     regexp_parser (2.8.1)
 85:     reverse_markdown (2.1.1)
 86:       nokogiri
 87:     rexml (3.2.6)
 88:     rspec (3.12.0)
 89:       rspec-core (~> 3.12.0)
 90:       rspec-expectations (~> 3.12.0)
 91:       rspec-mocks (~> 3.12.0)
 92:     rspec-core (3.12.2)
 93:       rspec-support (~> 3.12.0)
 94:     rspec-expectations (3.12.3)
 95:       diff-lcs (>= 1.2.0, < 2.0)
 96:       rspec-support (~> 3.12.0)
 97:     rspec-mocks (3.12.6)
 98:       diff-lcs (>= 1.2.0, < 2.0)
 99:       rspec-support (~> 3.12.0)
100:     rspec-support (3.12.1)
101:     rubocop (1.55.1)
102:       json (~> 2.3)
103:       language_server-protocol (>= 3.17.0)
104:       parallel (~> 1.10)
105:       parser (>= 3.2.2.3)
106:       rainbow (>= 2.2.2, < 4.0)
107:       regexp_parser (>= 1.8, < 3.0)
108:       rexml (>= 3.2.5, < 4.0)
109:       rubocop-ast (>= 1.28.1, < 2.0)
110:       ruby-progressbar (~> 1.7)
111:       unicode-display_width (>= 2.4.0, < 3.0)
112:     rubocop-ast (1.29.0)
113:       parser (>= 3.2.1.0)
114:     ruby-progressbar (1.13.0)
115:     ruby2_keywords (0.0.5)
116:     solargraph (0.50.0)
117:       backport (~> 1.2)
118:       benchmark
119:       bundler (~> 2.0)
120:       diff-lcs (~> 1.4)
121:       e2mmap
122:       jaro_winkler (~> 1.5)
123:       kramdown (~> 2.3)
124:       kramdown-parser-gfm (~> 1.1)
125:       parser (~> 3.0)
126:       rbs (~> 2.0)
127:       reverse_markdown (~> 2.0)
128:       rubocop (~> 1.38)
129:       thor (~> 1.0)
130:       tilt (~> 2.0)
131:       yard (~> 0.9, >= 0.9.24)
132:     solargraph-rails (0.2.2.pre.4)
133:       activesupport
134:       solargraph (>= 0.41.1)
135:     sorbet (0.5.11342)
136:       sorbet-static (= 0.5.11342)
137:     sorbet-runtime (0.5.11342)
138:     sorbet-static (0.5.11342-universal-darwin)
139:     sorbet-static (0.5.11342-x86_64-linux)
140:     sorbet-static-and-runtime (0.5.11342)
141:       sorbet (= 0.5.11342)
142:       sorbet-runtime (= 0.5.11342)
143:     spoom (1.3.0)
144:       erubi (>= 1.10.0)
145:       prism (>= 0.19.0)
146:       sorbet-static-and-runtime (>= 0.5.10187)
147:       thor (>= 0.19.2)
148:     tapioca (0.13.1)
149:       bundler (>= 2.2.25)
150:       netrc (>= 0.11.0)
151:       parallel (>= 1.21.0)
152:       rbi (>= 0.1.4, < 0.2)
153:       sorbet-static-and-runtime (>= 0.5.11087)
154:       spoom (>= 1.2.0)
155:       thor (>= 1.2.0)
156:       yard-sorbet
157:     thor (1.3.1)
158:     tilt (2.3.0)
159:     tzinfo (2.0.6)
160:       concurrent-ruby (~> 1.0)
161:     unicode-display_width (2.4.2)
162:     vcr (6.3.1)
163:       base64
164:     webmock (3.25.1)
165:       addressable (>= 2.8.0)
166:       crack (>= 0.3.2)
167:       hashdiff (>= 0.4.0, < 2.0.0)
168:     yard (0.9.36)
169:     yard-sorbet (0.8.1)
170:       sorbet-runtime (>= 0.5)
171:       yard (>= 0.9)
172: 
173: PLATFORMS
174:   arm64-darwin-21
175:   arm64-darwin-24
176:   x86_64-linux
177: 
178: DEPENDENCIES
179:   activesupport (>= 6.0)
180:   dotenv (>= 2)
181:   json-schema (~> 4.0)
182:   open_router!
183:   pry (>= 0.14)
184:   rake (~> 13.0)
185:   rspec (~> 3.0)
186:   rubocop (~> 1.21)
187:   solargraph-rails (~> 0.2.0.pre)
188:   sorbet
189:   tapioca
190:   vcr (~> 6.2)
191:   webmock (~> 3.19)
192: 
193: BUNDLED WITH
194:    2.4.12
</file>

<file path="LICENSE.txt">
 1: The MIT License (MIT)
 2: 
 3: Copyright (c) 2024 Obie Fernandez
 4: 
 5: Permission is hereby granted, free of charge, to any person obtaining a copy
 6: of this software and associated documentation files (the "Software"), to deal
 7: in the Software without restriction, including without limitation the rights
 8: to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9: copies of the Software, and to permit persons to whom the Software is
10: furnished to do so, subject to the following conditions:
11: 
12: The above copyright notice and this permission notice shall be included in
13: all copies or substantial portions of the Software.
14: 
15: THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16: IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17: FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18: AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19: LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20: OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
21: THE SOFTWARE.
</file>

<file path="open_router.gemspec">
 1: # frozen_string_literal: true
 2: 
 3: require_relative "lib/open_router/version"
 4: 
 5: Gem::Specification.new do |spec|
 6:   spec.name = "open_router"
 7:   spec.version = OpenRouter::VERSION
 8:   spec.authors = ["Obie Fernandez"]
 9:   spec.email = ["obiefernandez@gmail.com"]
10: 
11:   spec.summary = "Ruby library for OpenRouter API."
12:   spec.homepage = "https://github.com/OlympiaAI/open_router"
13:   spec.license = "MIT"
14:   spec.required_ruby_version = ">= 3.2.2"
15: 
16:   spec.metadata["homepage_uri"] = spec.homepage
17:   spec.metadata["source_code_uri"] = "https://github.com/OlympiaAI/open_router"
18:   spec.metadata["changelog_uri"] = "https://github.com/OlympiaAI/open_router/blob/main/CHANGELOG.md"
19: 
20:   spec.files = Dir.chdir(__dir__) do
21:     `git ls-files -z`.split("\x0").reject do |f|
22:       (File.expand_path(f) == __FILE__) || f.end_with?(".gem") || f.start_with?(*%w[bin/ test/ spec/ features/ .git
23:                                                                                     .circleci appveyor])
24:     end
25:   end
26: 
27:   spec.bindir = "exe"
28:   spec.executables = spec.files.grep(%r{\Aexe/}) { |f| File.basename(f) }
29:   spec.require_paths = ["lib"]
30: 
31:   spec.add_dependency "activesupport", ">= 6.0"
32:   spec.add_dependency "dotenv", ">= 2"
33:   spec.add_dependency "faraday", ">= 1"
34:   spec.add_dependency "faraday-multipart", ">= 1"
35: end
</file>

<file path="Rakefile">
 1: # frozen_string_literal: true
 2: 
 3: require "bundler/gem_tasks"
 4: require "rspec/core/rake_task"
 5: 
 6: RSpec::Core::RakeTask.new(:spec)
 7: 
 8: require "rubocop/rake_task"
 9: 
10: RuboCop::RakeTask.new
11: 
12: task default: %i[spec rubocop]
</file>

<file path="test_structured_output_fix.rb">
 1: require_relative 'lib/open_router'
 2: unless ENV['OPENROUTER_API_KEY']
 3:   puts "❌ No OPENROUTER_API_KEY found. Set environment variable and try again."
 4:   exit 1
 5: end
 6: puts "🧪 Testing structured output fix with real OpenRouter API call..."
 7: client = OpenRouter::Client.new(access_token: ENV['OPENROUTER_API_KEY'])
 8: schema = OpenRouter::Schema.define("simple_person") do
 9:   string :name, required: true, description: "Person's name"
10:   integer :age, required: true, description: "Person's age in years"
11:   string :occupation, required: false, description: "Person's job"
12: end
13: puts "\n📋 Schema format being sent:"
14: puts JSON.pretty_generate(client.send(:serialize_response_format, schema))
15: messages = [
16:   {
17:     role: "user",
18:     content: "Create JSON for a person named Alice who is 28 years old and works as a software engineer."
19:   }
20: ]
21: begin
22:   puts "\n🚀 Making API request..."
23:   response = client.complete(
24:     messages,
25:     model: "openai/gpt-4o-mini",
26:     response_format: schema,
27:     extras: { max_tokens: 200, temperature: 0.1 }
28:   )
29:   puts "✅ API request succeeded!"
30:   puts "\n📨 Raw response content:"
31:   puts response.content
32:   puts "\n📊 Structured output:"
33:   structured = response.structured_output
34:   puts structured.inspect
35:   puts "\n🧪 Validation checks:"
36:   puts "- Name is string: #{structured["name"].is_a?(String)}"
37:   puts "- Age is integer:
38:   puts "- Has name 'Alice': #{structured["name"]&.include?("Alice")}"
39:   puts "- Age is 28:
40:   if structured["occupation"]
41:     puts "- Has occupation: #{structured["occupation"]}"
42:   end
43:   puts "\n🎉 Test completed successfully! The 400 BadRequestError issue has been fixed."
44: rescue => e
45:   puts "❌ Test failed with error:"
46:   puts "Error class:
47:   puts "Error message: #{e.message}"
48:   if e.is_a?(OpenRouter::ServerError) && e.message.include?("400")
49:     puts "\n🔍 This is still the 400 error we're trying to fix."
50:     puts "The schema serialization may still have issues."
51:   else
52:     puts "\n📝 This might be a different issue (API key, network, model availability, etc.)"
53:   end
54:   exit 1
55: end
</file>

</files>
